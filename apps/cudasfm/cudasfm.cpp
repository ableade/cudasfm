#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
#include <set>
#include <fstream>
#include <utility>
//#include <pcl/point_cloud.h>
//#include <pcl/kdtree/kdtree_flann.h>
#include "shomatcher.hpp"
#include "shotracking.h"
#include "reconstructor.h"
#include <gflags/gflags.h>

using std::pair;
using std::cout;
using std::vector;
using std::endl;
using std::string;

DEFINE_bool(resize, false, "Choose whether to resize images before feature extraction");
DEFINE_string(images_directory, "", "The directory where the image files reside");
DEFINE_string(calibration_file, "", "Calibration file to use for the camera. Must be generated by open cv");
DEFINE_int32(max_image_size, 700, "If resizing, this is the max width to use for resizing");
DEFINE_string(feature_type, "ORB", "Feature detection algorithm to use. Choose from SIFT, SURF, ORB");

void writeMatchesToCSV(CommonTrack track, const vector<cv::Point2f>& points1, const vector<cv::Point2f>& points2) {
    std::ofstream outfile(track.imagePair.first + "-" + track.imagePair.second + "tracks.csv");
    outfile << "X1, Y1, X2, Y2 \n";
    for (auto i = 0; i < points1.size(); ++i) {
        outfile<< std::setprecision(8) << points1[i].x << "," << points1[i].y << "," << points2[i].x << "," << points2[i].y << "\n";
    }
    outfile.close();
}


void main_(int argc, char *argv[])
{
    string solverFlags = "-logtostderr";
    google::InitGoogleLogging(solverFlags.c_str());
#if 1
    string cameraCalibrationFile;
    if (argc < 2)
    {
        cout << "Program usage: <flight session directory> optional -- <camera calibration file>" << endl;
        exit(1);
    }
    FlightSession flight;
    (argc > 2) ? flight = FlightSession(argv[1], argv[2]) : flight = FlightSession(argv[1]);
    ShoMatcher shoMatcher(flight);

    //**** Begin Matching Pipeline ******
    if (argc > 3) {
        //A candidate file was provided 
        const auto candidateFile = argv[3];
        cout << "Using candidate file " << candidateFile << std::endl;
        shoMatcher.getCandidateMatchesFromFile(candidateFile);
    }
    else {
        double range = 0.000359;
        shoMatcher.getCandidateMatchesUsingSpatialSearch(range);
    }
    shoMatcher.extractFeatures(true);
    shoMatcher.runRobustFeatureMatching();
    //******End matching pipeline******
#if 1
    string image1 = "0058_SONY.jpg";
    string image2 = "0061_SONY.jpg";
#endif

#if 0
    string image1 = "resized_IMG_2889.jpg";
    string image2 = "resized_IMG_2891.jpg";
#endif
    //***Begin tracking pipeline *****
    ShoTracker tracker(flight, shoMatcher.getCandidateImages());
    vector<pair<ImageFeatureNode, ImageFeatureNode>> featureNodes;
    vector<FeatureProperty> featureProps;
    tracker.createFeatureNodes(featureNodes, featureProps);
    tracker.createTracks(featureNodes);
    auto tracksGraph = tracker.buildTracksGraph(featureProps);
    cout << "Created tracks graph " << endl;
    cout << "Number of vertices is " << tracksGraph.m_vertices.size() << endl;
    cout << "Number of edges is " << tracksGraph.m_edges.size() << endl;
    auto commonTracks = tracker.commonTracks(tracksGraph);
    cout << "Passed common tracks \n";
    Reconstructor reconstructor(flight, tracksGraph);
    
 
#if 0
    for (const auto &track : commonTracks)
    {
        if (track.imagePair.first == image1 && track.imagePair.second == image2)
        {
            cv::Mat mask;
           // reconstructor.plotTracks(track);
            const auto& [success, h, r, t]  = reconstructor.twoViewReconstruction(track, mask);
            cout << "Homography was " << h << "\n";
            cout << "Rotation was " << r << "\n";
            cout << "Translation was " << t << "\n";
            /*
            cout << "Homography was " << hom << endl;
            writeMatchesToCSV(track, points1, points2);
            vector<cv::Mat> Rs_decomp, ts_decomp, normals_decomp;
            auto gHom = flight.getCamera().getNormalizedKMatrix() * hom * flight.getCamera().getNormalizedKMatrix().inv();
            int solutions = decomposeHomographyMat(gHom, flight.getCamera().getNormalizedKMatrix(), Rs_decomp, ts_decomp, normals_decomp);
            vector<int> filteredSolutions;
            cv::filterHomographyDecompByVisibleRefpoints(Rs_decomp, normals_decomp, points1, points2, filteredSolutions, homMask);
            cout << "Size of filtered solutions were " << filteredSolutions.size() << endl;
            //cout << "Filtered solutions were " << filteredSolutions << endl;
            cout << "Decompose homography matrix computed from the camera displacement:" << endl << endl;
            for (auto i : filteredSolutions) 
            {
                cv::Mat normal = (cv::Mat_<double>(3, 1) << 0, 0, 1);
                cv::Mat origin(3, 1, CV_64F, cv::Scalar(0));
               // cv::Mat origin1 = Rs_decomp[i] * origin + ts_decomp.at(i).t;
                cv::Mat normal1 = Rs_decomp[i] * normal;
                //double d_inv1 = 1.0 / normal1.dot(origin1);
                cv::Mat rvec_decomp;
                Rodrigues(Rs_decomp[i], rvec_decomp);
                cout << "Solution " << i << ":" << endl;
                cout << "rvec from homography decomposition: " << rvec_decomp.t() << endl;
                //cout << "rvec from camera displacement: " << rvec_1to2.t() << endl;
                cout << "tvec from homography decomposition: " << ts_decomp.at(i).t() << endl;
                //cout << "tvec from camera displacement: " << t_1to2.t() << endl;
                cout << "plane normal from homography decomposition: " << normals_decomp.at(i).t() << endl;
            }
           
            shoMatcher.plotMatches(track.imagePair.first, track.imagePair.second);
            cv::waitKey(0);
            */
        }
    }
#endif
    reconstructor.runIncrementalReconstruction(tracker);
    cout << "Finished incremental runIncrementalReconstructionreconstruction \n\n";

#endif
    /*
  harvFile.open("harv.csv"); wsgFile.open("wsg.csv");
  //Compute nearest neighbors using haversine formula
  harvFile << "Image name, Neighboring image name, Distance,"<<endl;
  wsgFile << "Image name, Neighboring image name, Distance,"<<endl;
  for(auto i =0; i< v.size();++i) {
   vector<pair<string,double > > harvDistances;
   vector<pair<string,double > > wsgDistances;
   auto currentImage = parseFileNameFromPath(v[i].path().string());
   cout<<std::fixed<<std::setprecision(7);
   cout<<"Current image is " << currentImage<<endl;
   cout << "Coordinates for current image are "<<mosaicImages[i].location<<endl;
   cout << "ECEF for current image is " << mosaicImages[i].location.ecef()<<endl;
   for (int j=0; j < v.size();++j) {
     if (j == i) {
       continue;
     }
             //calculate distance from v[i] tp v[j]

     auto harvesineDistance = mosaicImages[i].location.distanceTo(mosaicImages[j].location);
     auto wsgDistance = mosaicImages[i].location.wgDistanceTo(mosaicImages[j].location);

     auto harvPair = make_pair(mosaicImages[j].fileName, harvesineDistance);
     auto wsgPair = make_pair(mosaicImages[j].fileName, wsgDistance);
     harvDistances.push_back(harvPair);
     wsgDistances.push_back(wsgPair);
             //cout << "Coordinates for compare image are "<<mosaicImages[j].location<<endl;
             //cout << "Haversine distance is "<< harvesineDistance<<endl;
             //cout << "ECEF for compare image is "<<mosaicImages[j].location.ecef()<<endl;
             //cout << "Wsg distance is "<<wsgDistance<<endl;
   }
   sort (harvDistances.begin(), harvDistances.end(), pairCompare);
   sort (wsgDistances.begin(), wsgDistances.end(), pairCompare);
   for(int j=0; j<k; ++j) {
     harvFile << currentImage<<","<<harvDistances[j].first<<","<<std::fixed<<std::setprecision(7)<<harvDistances[j].second<<","<<endl;
     wsgFile  << currentImage <<"," << wsgDistances[j].first<<","<<std::fixed<<std::setprecision(7)<<wsgDistances[j].second<<","<<endl;
   }
   cout << "*********************"<<endl;
  }
  harvFile.close();
  wsgFile.close();
  */
    }

int main(int argc, char* argv[])
{
    using std::cerr;
    using std::cout;

    {
        main_( argc, argv );
        cout << "End of program.\n";
        return EXIT_SUCCESS;
    }

    cout << "End of program due to error.\n";
    return EXIT_FAILURE;
}